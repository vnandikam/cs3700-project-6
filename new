#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random

BROADCAST = "FFFF"
LOWER_TIMEOUT = 200
UPPER_TIMEOUT = 400
HEARTBEAT_PERIOD = 100

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others
        self.state = "follower"
        self.leader = BROADCAST
        self.voted_for = ""
        self.term = 0


        self.commit_index = -1
        self.last_applied = -1

        
        self.log = []
        self.timeout_time = 0

        self.database = {}

        # candidate
        self.votes = 0
        self.missing_responses = []
        
        # leader 
        self.next_index = {}
        self.heartbeat_time = 0

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": self.leader, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    # DONE
    def send(self, message):
        '''
        Sends given message to port

        Parameters:
            message - message to send
        Returns: None
        '''
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))
    
    # DONE
    def redirect(self, message):
        '''
        Sends redirect message to client

        Parameters:
            message - message sent by client
        Returns: None
        '''
        if (self.state != "leader"):
            redirect_message = {"src": self.id, 
                                "dst": message["src"], 
                                "leader": self.leader, 
                                "type": "redirect", 
                                "MID": message["MID"]}
            self.send(redirect_message)
    
    # DONE
    def fail_message(self, message):
        '''
        Sends fail message to client

        Parameters:
            message - message sent by client
        Returns: None
        '''
        fail_message = {"src": self.id, 
                        "dst": message["src"], 
                        "leader": self.leader, 
                        "type": "fail", 
                        "MID": message["MID"]}
        self.send(fail_message)

    def message_type(self, message):
        '''
        Determines message type and calls corresponding handler function

        Parameters:
            message - message received 
        Returns: None
        '''
        types = {
            "get": self.handle_get,
            "put": self.handle_put,
            "RequestVote": self.handle_request_vote,
            "vote": self.handle_receive_vote,
            "AppendEntries": self.handle_append_entries,
            "AppendEntriesResponse": self.handle_append_entries_response
        }

        types[message["type"]](message)

    # DONE
    def handle_put(self, message):
        '''
        Handles a put message

        Parameters:
            message - put message received
        Returns: None
        '''
        if (self.state == "leader"):
            log_action = {"term": self.term, 
                          "index": len(self.log),
                          "type": "put",
                          "client": message["src"],
                          "servers": 1,
                          "MID": message["MID"],
                          "key": message["key"],
                          "value": message["value"]}
            self.log.append(log_action)
        elif (self.state != "leader"):
            self.redirect(message)

    # DONE
    def handle_get(self, message):
        '''
        Handles a get message

        Parameters:
            message - get message received
        Returns: None
        '''
        value = self.database.get(message["key"], "")

        if (self.state == "leader"):
            response = {"src": self.id, 
                        "dst": message["src"], 
                        "leader": self.leader, 
                        "type": "ok", 
                        "MID": message["MID"],
                        "value": value}
            self.send(response)

        if (self.state != "leader"):
            self.redirect(message)

    # DONE 
    def handle_request_vote(self, message):
        '''
        Handles a request vote message

        Parameters:
            message - request vote message received
        Returns: None
        '''
        candidate_term = message["term"]

        if (self.term < candidate_term):
            self.term = candidate_term
            if self.more_current(message):
                self.voted_for = message["src"]
                self.leader = message["src"]
                self.reset_timeout()
                self.vote(message, True)
            else:
                self.vote(message, False)

            if (self.state == "leader"):
                self.state = "follower"

        elif (self.term == candidate_term):
            self.vote(message, self.voted_for == message["src"])
            self.reset_timeout()

        else:
            self.vote(message, False)

    # DONE - think about using last term versus current term
    def more_current(self, message):
        '''
        Determines the more current log 
        
        Parameters:
            message - the request vote message that provides information on candidate's log
        Returns:
            True/False - is the candidate's log more current?
        '''
        log_length = len(self.log)
        my_last_term = (0 if (log_length == 0) else self.log[-1]["term"])
        candidate_last_term = message["log_term"]

        # candidate has higher last log term
        if (my_last_term < candidate_last_term):
            return True
        # if equal terms, candidate has longer log
        elif (my_last_term == candidate_last_term):
            return (log_length - 1 <= message["log_index"])
        # I have higher last log term
        else:
            return False

    # DONE
    def handle_receive_vote(self, message):
        '''
        Handles a vote message

        Parameters:
            message - vote message received
        Returns: None
        '''
        if (self.state != "candidate"):
            return

        voter = message["src"]
        if (voter not in self.missing_responses):
            return
        
        self.missing_responses.remove(voter)

        if (message["vote"]):
            self.votes += 1
        elif (not message["vote"]):
            voter_term = message["term"]

            if (voter_term > self.term):
                self.term = voter_term
        
        # more than half of servers votes for me
        self.win_election()

    # DONE
    def win_election(self):
        '''
        Handles winning an election
        
        Parameters: None
        Returns: None
        '''
        print(f'{self.votes} VOTES FOR {self.id}')
        if (self.votes < ((len(self.others) + 1) / 2.0)):
            return
        
        self.state = "leader"
        self.leader = self.id
        self.send_heartbeat()

        for follower in self.others:
            self.next_index[follower] = len(self.log)

    def handle_append_entries(self, message):
        '''
        Handles an append entries RPC from the leader

        Parameters:
            message - the append entries RPC that is received
        Returns: None
        '''
        message_term = message["term"]
        entries = message["entries"]
        matched_index = message["prev_log_index"]
        match = False
        conflict_index = -1
        conflict_term = -1
        entry_indices = [entry["index"] for entry in entries]

        if (message_term < self.term):
            self.append_entries_response(match, conflict_index, conflict_term, entry_indices, message["src"])
            return
        
        self.reset_timeout()
        self.leader = message["src"]
        self.state = "follower"
        self.term = message_term

        if (len(entries) == 0) or (len(self.log) == 0):
            self.append_entries_response(True, conflict_index, conflict_term, entry_indices, message["src"])
            self.log += entries
            return
        
        match, conflict_term, conflict_index = self.fix_log(message["prev_log_term"], matched_index, entries)
        self.append_entries_response(match, conflict_term, conflict_index, entry_indices, message["src"])

        leader_commit = message["commit_index"]
        if match and (leader_commit > self.commit_index):
            self.commit_index = min(leader_commit, len(self.log) - 1)

    def fix_log(self, prev_term, matched_index, entries):
        '''
        Determines if logs match between leader and follower and responds accordingly

        Parameters:
            prev_term - term of previous entry in leader's log
            matched_index - the index of the leader's previous entry
            entries - the entries sent from leader

        Returns:
            match - does my log match the leader's?
            conflict_term - if no match, term of conflicting entry
            conflict_index - if no match, index of conflicting
        '''
        match = False

        try: # my log is longer or same length as leader's
            my_same_entry = self.log[matched_index]
            # same entry in my log as leader's
            if (my_same_entry["term"] == prev_term):
                match = True
                matched_log = self.log[:matched_index + 1]
                self.log = matched_log + entries
                conflict_index, conflict_term = -1
            else: 
                conflict_term = my_same_entry["term"]
                conflict_index = self.find_first_of_term(conflict_term)
        except:
            my_last_entry = self.log[-1]
            conflict_index = len(self.log) - 1
            conflict_term = my_last_entry["term"]
        
        return match, conflict_term, conflict_index

    def handle_append_entries_response(self, message):
        '''
        Handles the response of an append entries message, sent by followers

        Parameters:
            message - the response message
        Returns:
            None
        ''' 
        server_id = message["src"]
        entries = message["entries"]

        if (self.term < message["term"]) or (self.state == "follower") or (self.id != message["leader"]):
            self.state = "follower"
            return

        if (message["success"]):
            if (len(entries) == 0):
                return
            for index in entries:
                self.log[index]["servers"] += 1
                self.check_committed(self.log[index])
                
            self.next_index[server_id] = message["entries"][-1] + 1
            print(f'NEXT INDEX {self.next_index}')
        else:
            conflict_index = message["conflict_index"]
            print(f'CONFLICT INDEX {conflict_index}')
            conflict_term = message["conflict_term"]
            leader_conflict_entry = self.log[conflict_index]

            # this matches the entry the replica sent back, so send this one and all after back
            if (leader_conflict_entry["term"] == conflict_term):
                self.next_index[server_id] = conflict_index
            # doesn't match the entry replica send back, so send previous term and all after
            else:
                prev_term_idx = self.find_first_of_term(conflict_term - 1)
                self.next_index[server_id] = prev_term_idx
    
    def check_committed(self, action):
        '''
        Determine if this action in log is to be committed (quorum reached)

        Parameters:
            action - the action in the log to be checked for quorum
        Returns: None
        '''
        if (action["servers"] < (1 + len(self.others)) / 2.0):
            return

        if (action["index"] > self.commit_index):
            print(f'COMMIT {self.commit_index} {self.log[self.commit_index]}')
            self.commit_index += 1 
    
    def find_first_of_term(self, term):
        '''
        Finds the first entry in the server's log with the given term

        Parameters:
            term - the term to find the first entry for
        Returns:
            index - index of first entry of the term
        '''
        for index in range(0, len(self.log)):
            entry = self.log[index]

            if (entry["term"] == term):
                return index

    def append_entries_response(self, success, conflict_term, conflict_index, entries, dst):
        '''
        Sends response to append entries RPC

        Parameters:
            success - did the server successfully replicate the append entries request?
            conflict_term - if there is conflict, term of entry's conflicting term
            conflict_index - if there is conflict, term of entry's conflicting index
            entries - indices of entries received from leader
            dst - where to send message to 
        Returns: None
        '''
        response = {
            "src": self.id,
            "dst": dst,
            "leader": self.leader,
            "type": "AppendEntriesResponse",
            "term": self.term,
            "success": success,
            "conflict_term": conflict_term,
            "conflict_index": conflict_index,
            "entries": entries}
        
        self.send(response)

    def send_append_entries(self, replica, entries, prev_log_index, prev_log_term):
        '''
        Sends an append entries RPC as heart beat or to update server logs

        Parameters:
            replica - the server to send the message to
            entries - entries to send
            prev_log_index - previous log index
            prev_log_term - previous log term
        Returns: None
        '''
        append_entries_message = {"src": self.id,
                                  "dst": replica,
                                  "leader": self.id,
                                  "type": "AppendEntries",
                                  "term": self.term,
                                  "prev_log_index": prev_log_index,
                                  "prev_log_term": prev_log_term,
                                  "entries": entries,
                                  "commit_index": self.commit_index}
        self.send(append_entries_message)
    
    # DONE
    def vote(self, message, vote):
        '''
        Sends a vote message

        Parameters:
            message - request vote message received (message to respond to)
            vote - the vote for the candidate to be leader (yes or no)
        Returns: None
        '''
        vote = {"src": self.id, 
                "dst": message["src"],
                "leader": self.leader,
                "type": "vote",
                "vote": vote,
                "term": self.term}
        self.send(vote)

    # DONE
    def send_request_vote(self, replica):
        '''
        Sends a request vote message

        Parameters:
            replica - the server to send the request vote RPC to
        Returns: None
        '''
        log_length = len(self.log)
        request_vote_message = {"src": self.id, 
                                "dst": replica, 
                                "leader": self.leader, 
                                "type": "RequestVote",
                                "term": self.term,
                                "log_term": (0 if (log_length == 0) else self.log[-1]["term"]),
                                "log_index": len(self.log) - 1}
        self.send(request_vote_message)

    # DONE 
    def election(self):
        '''
        Begins and runs an election for this server

        Parameters: None
        Returns: None
        '''
        self.term += 1
        self.leader = self.id
        self.state = "candidate"
        self.votes = 1
        self.missing_responses = self.others.copy()

        self.reset_timeout()
        self.send_request_vote(BROADCAST)
        self.heartbeat_time = time.time() + (HEARTBEAT_PERIOD / 1000.0)
    
    # DONE
    def resend_request_vote(self):
        '''
        Resends a request vote if not heard back from server in heartbeat period of time

        Parameters: None
        Returns: None
        '''
        if (self.state != "candidate"):
            return
        
        if (time.time() > self.heartbeat_time):
            for server in self.missing_responses:
                self.send_request_vote(server)

    # DONE
    def reset_timeout(self):
        '''
        Resets the election timeout value

        Parameters: None
        Returns: None 
        '''
        start_time = time.time()
        timeout_period = random.randint(LOWER_TIMEOUT, UPPER_TIMEOUT) / 1000.0
        self.timeout_time = start_time + timeout_period

    # DONE
    def handle_timeout(self):
        '''
        Handles a timeout

        Parameters: None
        Returns: None
        '''
        if (self.state == "leader"):
            return
        
        current_time = time.time()

        if (current_time >= self.timeout_time):
            self.election()

    # DONE
    def send_heartbeat(self):
        '''
        Sends append entries messages at a constant rate if leader to ensure no election timeouts

        Parameters: None
        Returns: None
        '''
        current_time = time.time()

        if (self.state == "leader") and (current_time >= self.heartbeat_time):
            for follower, next_index in self.next_index.items():
                print(f'Sent AE to {follower}')
                if (next_index == len(self.log)):
                    self.send_append_entries(follower, [], -1, -1)
                    continue

                next_entries = self.log[next_index:]

                prev_entry = self.log[next_index - 1]
                prev_term = prev_entry["term"]

                self.send_append_entries(follower, next_entries, next_index - 1, (0 if (next_index == 0) else prev_term))

            self.heartbeat_time = current_time + (HEARTBEAT_PERIOD / 1000.0)

    def update_database(self):
        '''
        Updates the database by performing committed actions to the state machine

        Parameters: None
        Returns: None
        '''
        edit_actions = {
            "put": self.perform_put
        }

        while (self.last_applied < self.commit_index):
            print(f'Last applied: {self.last_applied}')
            print(f'Commit idx: {self.commit_index}')
            self.last_applied += 1            
            action_to_apply = self.log[self.last_applied]

            edit_actions[action_to_apply["type"]](action_to_apply)
        
    # DONE
    def perform_put(self, action):
        '''
        Performs put action on state machine and notifies client

        Parameters:
            action - put action from log
        Returns: None
        '''
        self.database[action["key"]] = action["value"]

        if (self.state == "leader"):
            response = {"src": self.id, 
                        "dst": action["client"], 
                        "leader": self.leader, 
                        "type": "ok", 
                        "MID": action["MID"]}
            self.send(response)

    def run(self):
        '''
        Reads input on socket and calls corresponding handler function
        Also sends heartbeat, handles timeouts, and updates database

        Parameters: None
        Returns: None
        '''
        self.reset_timeout()
        while True:
            socket = [self.socket]
            active = select.select(socket, [], [], 0.1)[0]

            for connection in active:
                data, addr = connection.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                print("Received message '%s'" % (msg), flush=True)

                self.message_type(msg)

            # if leader, sends heartbeat
            self.send_heartbeat()
            # if timeout, begins election
            self.handle_timeout()
            self.resend_request_vote()
            self.update_database()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()