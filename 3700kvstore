#!/usr/bin/env python3

import argparse, socket, time, json, select, struct, sys, math, os, random
from enum import Enum

class State(Enum):
    LEADER  = 0
    CANDIDATE = 1
    FOLLOWER = 2

BROADCAST = "FFFF"
STANDARD_TIMEOUT = 0.15
# STATE = {'candidate', 'follower', 'leader'}

class Replica:
    def __init__(self, port, id, others):
        self.database = {}
        self.port = port
        self.id = id
        self.others = others
        self.state = State.FOLLOWER
        self.curr_leader = 'FFFF'
        self.curr_term_number = 0

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
       #  print('Replica ' + str(self.id) + ' sent ' + str(message))
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))

    def send_heartbeat(self):
        msg = {'src': self.id, 'dst': 'FFFF', 
                'leader': self.id, 
                "type": "append-entries", 
                'term': self.curr_term_number}
        self.send(msg)

    def run(self):
        curr_term_number = 0
        votes = 0
        looking_for_votes = False
        sent_vote_for_term = False
        last_heartbeat = time.time()
        while True:

            # use time in python instead of setting select for the timeout
            # track the last time we sent a heartbeat/recieved a heartbeat
            timeout = STANDARD_TIMEOUT / 2
            if self.state != State.LEADER:
                timeout = (random.random() + 1) * STANDARD_TIMEOUT
            
            sock = select.select([self.socket], [], [], 0.05)[0]
            for conn in sock:
                data, addr = conn.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                # print("Received message '%s'" % (msg,), flush=True)    
                
                ### MESSAGE OPTIONS ###
                if msg['type'] == 'append-entries': # receive heartbeat
                    last_heartbeat = time.time()
                    self.curr_leader = msg['leader']
                    looking_for_votes = False
                    sent_vote_for_term = False
                    votes = 0
                    self.state = State.FOLLOWER
                    print("Received message '%s'" % (msg,), flush=True)

                elif msg['type'] == 'request_rpc' and not sent_vote_for_term: # vote for rpc
                    self.state = State.FOLLOWER
                    msg = {'src': self.id, 'dst': msg['src'], 
                            'leader': 'FFFF',
                            "type": "vote"}
                    self.send(msg)
                    last_heartbeat = time.time()
                    sent_vote_for_term = True
                    print("Received message '%s'" % (msg,), flush=True)
                
                elif msg['type'] == 'vote': # and looking_for_votes and not sent_vote_for_term: # increment votes and see if i make quorum
                    votes += 1
                    if votes >= ((math.floor(len(self.others)/2)) + 1):
                        msg = {'src': self.id, 'dst': 'FFFF', 
                                'leader': self.id,
                                "type": "append-entries", 
                                'term': curr_term_number}
                        self.send(msg)
                        looking_for_votes = False
                        votes = 0
                        self.curr_leader = self.id
                        self.state = State.LEADER
                    print("Received message '%s'" % (msg,), flush=True)

                if time.time() - last_heartbeat > timeout:
                    if self.state == State.LEADER:
                        self.send_heartbeat()
                        last_heartbeat = time.time()
                    else:
                        self.state = State.CANDIDATE
                        curr_term_number += 1
                        msg = {'src': self.id, 'dst': 'FFFF', 
                                'leader': 'FFFF', 
                                "type": "request_rpc", 
                                'log-length': len(self.database)}
                        votes += 1
                        self.send(msg)
                        looking_for_votes = True

                if msg['type'] == 'put':
                    mid = msg['MID']
                    response = {"src": self.id, "dst": msg['src'], "leader": self.curr_leader, "type": "fail", "MID": mid}
                    self.send(response)
                elif msg['type'] == 'get':
                    response = {"src": self.id, "dst": msg['src'], "leader": self.curr_leader, "type": "fail", "MID": mid}
                    self.send(response)




if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
