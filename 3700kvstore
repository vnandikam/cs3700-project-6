#!/usr/bin/env python3

import argparse, socket, time, json, random, select, struct, sys, math, os
from enum import Enum

class State(Enum):
    LEADER  = 0
    CANDIDATE = 1
    FOLLOWER = 2


BROADCAST = "FFFF"
STANDARD_TIMEOUT = 200

class Replica:
    def __init__(self, port, id, others):
        self.port = port
        self.id = id
        self.others = others

        self.replica_timeout = 0
        self.leader_timeout = 0

        self.commit_index = 0
        self.log_index = 0
        self.term = 0
        self.state = State.FOLLOWER

        self.leader = BROADCAST
        self.votes = 0
        self.voted_leader = ''
        self.replicas_not_voted = self.others.copy()
        self.log = {}
        self.database = {}

        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(('localhost', 0))

        print("Replica %s starting up" % self.id, flush=True)
        hello = { "src": self.id, "dst": BROADCAST, "leader": BROADCAST, "type": "hello" }
        self.send(hello)
        print("Sent hello message: %s" % hello, flush=True)

    def send(self, message):
        self.socket.sendto(json.dumps(message).encode('utf-8'), ('localhost', self.port))
    
    
    def reset_replica_timeout(self):
        self.replica_timeout = time.time() + random.randint(STANDARD_TIMEOUT, STANDARD_TIMEOUT*2) / 1000.0


    def recv_append_entry(self, msg):
        self.reset_replica_timeout()
        self.leader = msg["src"]
        self.state = State.FOLLOWER
        self.term = msg['term']


    def leader_heartbeat(self, log_index):
        prev_term_number = -1
        if (log_index - 1) in self.log.keys():
            prev_term_number = self.log[log_index - 1]['term']

        append_msg = {'src': self.id, 'dst': BROADCAST,
                      'leader': self.id, 
                      'type': "append-entries", 
                      'leader_commit': self.log_index,
                      'term': self.term,
                      'prev_log_index': self.log_index - 1,
                      'prev_log_term': prev_term_number,
                      'entries': [],
                      'leader_commit_index': self.commit_index
                      }
        
        self.send(append_msg)

        self.leader_timeout = time.time() + (STANDARD_TIMEOUT / 2000.0)

    def start_election(self):
        self.leader = self.id
        self.state = State.CANDIDATE
        self.term += 1
        self.votes += 1
        self.replicas_not_voted = self.others.copy()
        #TODO: keep track of replicas who voted to make sure there are no duplicates
        # self.terms_voted_for.add(self.curr_term_number)

        self.reset_replica_timeout()
        self.leader_timeout = time.time() + STANDARD_TIMEOUT/2000.0

        msg = {'src': self.id, 'dst': 'FFFF', 
            'leader': self.id,
            "type": "request_rpc",
            'term': self.term,
            # TODO: include the term of the last log ? and use that to compare to replica's term instead
            'log-length': self.log_index}
        
        self.send(msg)


    def persist_request_rpc(self):
        for replica in self.replicas_not_voted:
            msg = {'src': self.id, 'dst': replica, 
                    'leader': self.id,
                    "type": "request_rpc",
                    'term': self.term,
                    # TODO: include the term of the last log ? and use that to compare to replica's term instead
                    'log-length': self.curr_log_idx}
            self.send(msg)

    def process_incoming_message(self, msg):
        if msg['type'] == 'request_rpc':
            self.receive_request_rpc(msg)
        elif msg['type'] == 'vote':
            if self.state == State.CANDIDATE and msg['src'] in self.replicas_not_voted:
                self.replicas_not_voted.remove(msg['src'])
                self.receive_vote(msg)
        elif msg['type'] == 'append-entries':
            self.recv_append_entry(msg)
        elif msg['type'] == 'put':
            self.recv_put(msg)
        elif msg['type'] == 'get':
            self.recv_get(msg)

    def recv_put(self, msg):
        if self.state == State.LEADER:
            self.database[msg['key']] = msg['value']
            response = {"src": self.id, "dst": msg['src'], "leader": self.leader, "type": "ok", "MID": msg['MID']}
            self.send(response)
        else:
            self.redirect_msg(msg)

    def recv_get(self, msg):
        if self.state == State.LEADER:
            value = self.database.get(msg['key'], '')
            response = {"src": self.id, "dst": msg['src'], "leader": self.leader, "type": "ok", "MID": msg['MID'], 'value': value}
            self.send(response)
        else:
            self.redirect_msg(msg)

    def redirect_msg(self, msg):
        response = {"src": self.id, "dst": msg['src'], "leader": self.leader, "type": "redirect", "MID": msg['MID']}
        self.send(response)



    def receive_vote(self, msg):
        if msg['should_vote']:
            self.votes += 1
        else:
            if msg['term'] > self.term:
                self.term = msg['term']

        if self.votes >= ((len(self.others) + 1) / 2.0):
            self.state = State.LEADER
            self.leader = self.id
            if time.time() >= self.leader_timeout:
                self.leader_heartbeat(self.log_index)
            

        

    def receive_request_rpc(self, msg):

        should_vote = None
        

        if msg['term'] < self.term:
            should_vote = False
        elif msg['term'] == self.term:
            self.reset_replica_timeout()
            should_vote = msg['src'] == self.voted_leader

        else:
            self.term = max(self.term, msg['term'])
            if len(self.log) <= msg['log-length']:
                # TODO: check previous log term with candidates previous term
                self.leader = msg['src']
                self.voted_leader = msg['src']
                self.reset_replica_timeout()
                should_vote = True
            else:
                should_vote = False

            if self.state != State.CANDIDATE:
                self.state = State.FOLLOWER

        vote_msg = {'src': self.id, 'dst': msg['src'], 
            'leader': self.leader,
            "type": "vote",
            'should_vote': should_vote,
            'term': self.term}
        
        self.send(vote_msg)

    def run(self):
        # TODO: CHANGE TO OUR METHOD OF TIMEOUT
        # TODO: see if we can consolidate the two timeouts into one
        self.reset_replica_timeout()

        while True:
            connections = select.select([self.socket], [], [], 0.01)[0]
            for conn in connections:
                data, addr = self.socket.recvfrom(65535)
                msg = json.loads(data.decode('utf-8'))
                print("Received message '%s'" % (msg,), flush=True)

                self.process_incoming_message(msg)
            
            
            if self.state == State.LEADER:
                if time.time() >= self.leader_timeout:
                    self.leader_heartbeat(self.log_index)
            else:
                if time.time() >= self.replica_timeout:
                    self.start_election()

            if self.state == State.CANDIDATE:
                if time.time() >= self.replica_timeout:
                    self.persist_request_rpc()
            
            # TODO: update database method

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='run a key-value store')
    parser.add_argument('port', type=int, help="Port number to communicate")
    parser.add_argument('id', type=str, help="ID of this replica")
    parser.add_argument('others', metavar='others', type=str, nargs='+', help="IDs of other replicas")
    args = parser.parse_args()
    replica = Replica(args.port, args.id, args.others)
    replica.run()
